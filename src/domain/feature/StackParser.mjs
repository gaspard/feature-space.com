// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "sury/src/S.mjs";
import * as Stack from "../api/entity/Stack.mjs";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import GrayMatter from "gray-matter";
import * as Core__Option from "@rescript/core/src/Core__Option.mjs";
import * as Caml_splice_call from "rescript/lib/es6/caml_splice_call.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

var contentRe = /^(.*?)\s*<details>/s;

var hintRe = /[\s\S]*?<details class=\"hint\">(.*?)<\/details>/;

var solutionRe = /[\s\S]*?<summary>.*?<\/summary>([\s\S]*?)<\/details>/;

function makeId() {
  var idx = {
    contents: 0
  };
  return function () {
    idx.contents = idx.contents + 1 | 0;
    return idx.contents.toString();
  };
}

function getOptions(content) {
  var id = makeId();
  var options = [];
  var rest = [];
  content.split("\n").forEach(function (l) {
        if (l.startsWith("- [x]")) {
          options.push({
                id: id(),
                content: l.slice(5).trim(),
                correct: true
              });
        } else if (l.startsWith("- [ ]")) {
          options.push({
                id: id(),
                content: l.slice(5).trim(),
                correct: false
              });
        } else {
          rest.push(l);
        }
      });
  return [
          rest.join("\n"),
          options
        ];
}

function parseCards(stackId, body) {
  var id = makeId();
  return body.split("\n---\n").map(function (prim) {
                  return prim.trim();
                }).filter(function (s) {
                if (s !== "" && !s.startsWith("# ")) {
                  return !s.startsWith("## ");
                } else {
                  return false;
                }
              }).map(function (text) {
              var r = contentRe.exec(text);
              var match = (r == null) ? (console.log("Cannot extract content\n=================="), console.log(text), console.log("=================="), Js_exn.raiseError("Cannot extract content")) : [
                  r[1],
                  text.slice(r[0].length)
                ];
              var text$1 = match[1];
              var content = match[0];
              var r$1 = hintRe.exec(text$1);
              var match$1;
              if (r$1 == null) {
                match$1 = [
                  content,
                  text$1
                ];
              } else {
                var match$2 = r$1.slice(1);
                if (match$2.length !== 1) {
                  match$1 = [
                    content,
                    text$1
                  ];
                } else {
                  var hint = match$2[0];
                  match$1 = [
                    content + hint,
                    text$1.slice(r$1[0].length)
                  ];
                }
              }
              var text$2 = match$1[1];
              var match$3 = getOptions(match$1[0]);
              var r$2 = solutionRe.exec(text$2);
              var match$4 = (r$2 == null) ? (console.log("Cannot extract solution\n=================="), console.log(text$2), console.log("=================="), Js_exn.raiseError("Cannot extract solution")) : [
                  r$2[1],
                  text$2.slice(r$2[0].length)
                ];
              return {
                      id: id(),
                      stackId: stackId,
                      content: match$3[0],
                      solution: match$4[0],
                      options: match$3[1]
                    };
            });
}

function parse(content) {
  var match = GrayMatter(content);
  var info = S.parseOrThrow(match.data, Stack.infoSchema);
  var cards = parseCards(info.id, match.content);
  return {
          info: {
            id: info.id,
            title: info.title,
            kind: info.kind,
            level: info.level,
            chapter: info.chapter,
            course: info.course,
            tags: info.tags,
            count: cards.length
          },
          cards: cards
        };
}

var pathRe = /(\.cards|\.quiz|\.proofs)$/;

function makeStacksToJson(fs, path) {
  return function (dir, outdir, stacksDir) {
    if (!fs.existsSync(stacksDir)) {
      fs.mkdirSync(stacksDir);
    }
    var aux = function (dir, outdir) {
      if (!fs.existsSync(outdir)) {
        fs.mkdirSync(outdir);
      }
      var toc = [];
      fs.readdirSync(dir).forEach(function (dirent) {
            if (!(dirent.name.endsWith(".cards") || dirent.name.endsWith(".quiz") || dirent.name.endsWith(".proofs"))) {
              if (dirent.isDirectory()) {
                Caml_splice_call.spliceObjApply(toc, "push", [aux(path.join(dir, dirent.name), path.join(outdir, dirent.name))]);
                return ;
              } else {
                return ;
              }
            }
            var p = path.join(dir, dirent.name);
            try {
              var stack = parse(fs.readFileSync(p, "utf-8"));
              toc.push(stack.info);
              var json = Core__Option.getExn(JSON.stringify(S.reverseConvertOrThrow(stack, Stack.stackSchema), undefined, 2), undefined);
              return fs.writeFileSync(path.join(stacksDir, stack.info.id + ".json"), json, "utf-8");
            }
            catch (raw_error){
              var error = Caml_js_exceptions.internalToOCamlException(raw_error);
              if (error.RE_EXN_ID === Js_exn.$$Error) {
                console.log("Error parsing stack file: " + p);
                console.log(error._1);
              } else {
                console.log("Error parsing stack file: " + p);
                console.log("Unknown error");
              }
              return ;
            }
          });
      if (toc.length > 0) {
        var json = Core__Option.getExn(JSON.stringify(S.reverseConvertOrThrow(toc, Stack.tocSchema), undefined, 2), undefined);
        fs.writeFileSync(path.join(outdir, "stacks-toc.json"), json, "utf-8");
      }
      return toc;
    };
    return aux(dir, outdir);
  };
}

export {
  contentRe ,
  hintRe ,
  solutionRe ,
  makeId ,
  getOptions ,
  parseCards ,
  parse ,
  pathRe ,
  makeStacksToJson ,
}
/* S Not a pure module */
