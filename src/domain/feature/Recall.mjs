// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Tilia from "tilia/src/Tilia.mjs";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Core__Array from "@rescript/core/src/Core__Array.mjs";
import * as CardProgress from "../api/entity/CardProgress.mjs";

function back(evaluate, card, boptions, setShowBack) {
  var options = boptions.map(function (option) {
        var match = option.checked;
        var match$1 = option.correct;
        var correction = match ? (
            match$1 ? "Correct" : "Incorrect"
          ) : (
            match$1 ? "Missed" : "Blank"
          );
        return {
                id: option.id,
                content: option.content,
                checked: option.checked,
                correction: correction
              };
      });
  return {
          TAG: "Back",
          _0: {
            content: card.content,
            solution: card.solution,
            options: options,
            evaluate: evaluate,
            turn: (function () {
                setShowBack(false);
              })
          }
        };
}

var Ui = {
  back: back
};

function sort(cards, dayLengthOpt) {
  var dayLength = dayLengthOpt !== undefined ? dayLengthOpt : 24 * 3600 * 1000;
  return cards.toSorted(function (param, param$1) {
              var b = param$1[1];
              var a = param[1];
              var aProgress = CardProgress.recallTime(a.timestamp, a.state, dayLength);
              var bProgress = CardProgress.recallTime(b.timestamp, b.state, dayLength);
              if (aProgress < bProgress) {
                return -1.0;
              } else if (aProgress === bProgress) {
                return 0.0;
              } else {
                return 1.0;
              }
            });
}

function recallCount(progs, nowOpt, dayLengthOpt) {
  var now = nowOpt !== undefined ? nowOpt : Date.now();
  var dayLength = dayLengthOpt !== undefined ? dayLengthOpt : 24 * 3600 * 1000;
  return progs.flatMap(function (prog) {
                return Object.values(prog.cards);
              }).filter(function (param) {
              return CardProgress.recallTime(param.timestamp, param.state, dayLength) <= now;
            }).length;
}

function toRecall(stacks, nowOpt, dayLengthOpt) {
  var now = nowOpt !== undefined ? nowOpt : Date.now();
  var dayLength = dayLengthOpt !== undefined ? dayLengthOpt : 24 * 3600 * 1000;
  var newCards = [];
  var seenCards = [];
  stacks.forEach(function (param) {
        var prog = param.prog;
        param.stack.cards.forEach(function (card) {
              var progress = prog.cards[card.id];
              if (progress !== undefined) {
                seenCards.push([
                      card,
                      progress
                    ]);
              } else {
                newCards.push(card);
              }
            });
      });
  var seenCards$1 = sort(seenCards, dayLength);
  var afterIdx = seenCards$1.findIndex(function (param) {
        var match = param[1];
        return CardProgress.recallTime(match.timestamp, match.state, dayLength) > now;
      });
  return (
              afterIdx !== -1 ? seenCards$1.slice(0, afterIdx) : seenCards$1
            ).map(function (param) {
                return param[0];
              }).concat(newCards);
}

function nextRecall(stacks, shuffleOpt, nowOpt, maxOpt, dayLengthOpt) {
  var shuffle = shuffleOpt !== undefined ? shuffleOpt : Core__Array.shuffle;
  var now = nowOpt !== undefined ? nowOpt : Date.now();
  var max = maxOpt !== undefined ? maxOpt : 20;
  var dayLength = dayLengthOpt !== undefined ? dayLengthOpt : 24 * 3600 * 1000;
  var toRecall$1 = toRecall(stacks, now, dayLength).slice(0, max);
  shuffle(toRecall$1);
  return toRecall$1;
}

function make(repo, stacks, shuffleOpt, nowOpt, maxOpt, dayLengthOpt) {
  var shuffle = shuffleOpt !== undefined ? shuffleOpt : Core__Array.shuffle;
  var now = nowOpt !== undefined ? nowOpt : (function (prim) {
        return Date.now();
      });
  var max = maxOpt !== undefined ? maxOpt : 20;
  var dayLength = dayLengthOpt !== undefined ? dayLengthOpt : 24 * 3600 * 1000;
  var stacks$1 = Tilia.tilia(stacks);
  var match = Tilia.signal(nextRecall(stacks$1, shuffle, now(), max, dayLength));
  var stack = match[0];
  var card = Tilia.derived(function () {
        return stack.value[0];
      });
  var prog = Object.fromEntries(stacks$1.map(function (param) {
            var prog = param.prog;
            return [
                    prog.id,
                    prog
                  ];
          }));
  var match$1 = Tilia.signal(false);
  var setShowBack = match$1[1];
  var showBack = match$1[0];
  var evaluate = function (state) {
    var card$1 = card.value;
    if (card$1 === undefined) {
      return Js_exn.raiseError("No card selected");
    }
    var p = prog[card$1.stackId];
    if (p === undefined) {
      return Js_exn.raiseError("No progress found for card " + card$1.stackId);
    }
    var c = CardProgress.next(p.cards[card$1.id], state, now());
    p.cards[card$1.id] = c;
    repo.progress.save(p);
    setShowBack(false);
    var card$2 = stack.value.shift();
    if (card$2 !== undefined && state === "again") {
      stack.value.push(card$2);
      return ;
    }
    
  };
  var stats = Tilia.derived(function () {
        var total = Core__Array.reduce(stacks$1, 0, (function (acc, param) {
                return acc + param.stack.cards.length | 0;
              }));
        var seen = Core__Array.reduce(stacks$1, 0, (function (acc, param) {
                return acc + Object.values(param.prog.cards).length | 0;
              }));
        var newCount = total - seen | 0;
        return {
                total: total,
                seen: seen,
                new: total - seen | 0,
                toRecall: toRecall(stacks$1, now(), dayLength).length - newCount | 0,
                stackCount: stack.value.length
              };
      });
  var options = Tilia.derived(function () {
        var card$1 = card.value;
        if (card$1 !== undefined) {
          return card$1.options.map(function (option) {
                      return {
                              id: option.id,
                              content: option.content,
                              correct: option.correct,
                              checked: false
                            };
                    });
        } else {
          return [];
        }
      });
  var view = Tilia.derived(function () {
        var card$1 = card.value;
        if (card$1 !== undefined) {
          if (showBack.value) {
            return back(evaluate, card$1, options.value, setShowBack);
          } else {
            return {
                    TAG: "Front",
                    _0: {
                      content: card$1.content,
                      options: options.value,
                      turn: (function () {
                          setShowBack(true);
                        })
                    }
                  };
          }
        } else {
          return "Done";
        }
      });
  return Tilia.tilia({
              card: Tilia.lift(card),
              evaluate: evaluate,
              view: Tilia.lift(view),
              stack: Tilia.lift(stack),
              stats: Tilia.lift(stats)
            });
}

export {
  Ui ,
  sort ,
  recallCount ,
  toRecall ,
  nextRecall ,
  make ,
}
/* Tilia Not a pure module */
