// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Tilia from "tilia/src/Tilia.mjs";
import * as Recall from "./Recall.mjs";
import * as Core__Int from "@rescript/core/src/Core__Int.mjs";
import * as Core__Array from "@rescript/core/src/Core__Array.mjs";
import * as Core__Float from "@rescript/core/src/Core__Float.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.mjs";
import * as Core__Nullable from "@rescript/core/src/Core__Nullable.mjs";

function isActive(param) {
  var prog = param.prog;
  if (typeof prog !== "object") {
    return false;
  } else {
    return prog._0.active;
  }
}

function stats(now) {
  return function (param) {
    var stacks = param.stacks.filter(isActive);
    var total = Core__Array.reduce(stacks, 0, (function (acc, elem) {
            var p = elem.prog;
            var tmp;
            tmp = typeof p !== "object" || !p._0.active ? 0 : Core__Option.getOr(elem.info.count, 0);
            return acc + tmp | 0;
          }));
    var seen = Core__Array.keepSome(stacks.map(function (param) {
              var prog = param.prog;
              if (typeof prog !== "object") {
                return ;
              } else {
                return prog._0;
              }
            }));
    var seenCount = Core__Array.reduce(seen, 0, (function (acc, prog) {
            return acc + Object.values(prog.cards).length | 0;
          }));
    return {
            toRecall: Recall.recallCount(seen, now(), param.dayLengthH * 3600 * 1000),
            seen: seenCount,
            new: total - seenCount | 0,
            total: total
          };
  };
}

function start(repo) {
  return function (param) {
    var maxCards = param.maxCards;
    var dayLengthH = param.dayLengthH;
    var stacks = param.stacks;
    return async function (setRecall) {
      var stacks$1 = Core__Array.keepSome(await Promise.all(stacks.map(async function (param) {
                    var prog = param.prog;
                    var info = param.info;
                    if (typeof prog !== "object") {
                      return ;
                    }
                    var prog$1 = prog._0;
                    if (!prog$1.active) {
                      return ;
                    }
                    var stack = await repo.stack.get(info.id);
                    if (stack !== undefined) {
                      return {
                              stack: stack,
                              prog: prog$1
                            };
                    } else {
                      console.log("Stack not found: ", info.id);
                      return ;
                    }
                  })));
      return setRecall(Recall.make(repo, stacks$1, undefined, undefined, maxCards, dayLengthH * 3600 * 1000));
    };
  };
}

async function loadProgress(prog, set, info) {
  var p = await prog.get(info.id);
  if (p !== undefined) {
    return set({
                info: info,
                prog: {
                  TAG: "Started",
                  _0: p
                }
              });
  } else {
    return set({
                info: info,
                prog: "NotStarted"
              });
  }
}

function stacks(repo, path) {
  return async function (_prev, setList) {
    var list = (await repo.stack.toc(path)).map(function (info) {
          return {
                  info: info,
                  prog: "Loading"
                };
        });
    setList(list);
    list.forEach(function (param, i) {
          loadProgress(repo.progress, (function (extra) {
                  list[i] = extra;
                }), param.info);
        });
  };
}

function setActive(param) {
  var save = param.save;
  return function (param) {
    var stacks = param.stacks;
    return function (id, active) {
      var i = stacks.findIndex(function (v) {
            return v.info.id === id;
          });
      if (i === -1) {
        return ;
      }
      var match = stacks[i];
      if (match === undefined) {
        return ;
      }
      var p = match.prog;
      var info = match.info;
      if (typeof p !== "object") {
        if (p === "Loading") {
          return ;
        }
        var p$1 = {
          id: info.id,
          active: active,
          cards: {}
        };
        stacks[i] = {
          info: info,
          prog: {
            TAG: "Started",
            _0: p$1
          }
        };
        save(p$1);
        return ;
      } else {
        var p$2 = p._0;
        p$2.active = active;
        save(p$2);
        return ;
      }
    };
  };
}

function make(repo, path) {
  var day = Core__Option.getOr(Core__Float.fromString(Core__Nullable.getOr(repo.settings.get("dayLength"), "24")), 24);
  var maxCards = Core__Option.getOr(Core__Int.fromString(Core__Nullable.getOr(repo.settings.get("maxCards"), "20"), undefined), 20);
  var match = Tilia.signal(day);
  var setDayLengthH = match[1];
  var dayLengthH = match[0];
  var match$1 = Tilia.signal(maxCards);
  var setMaxCards = match$1[1];
  var maxCards$1 = match$1[0];
  var setDayLength = function (value) {
    repo.settings.save("dayLength", value.toString());
    setDayLengthH(value);
  };
  var setMaxCards$1 = function (value) {
    repo.settings.save("maxCards", value.toString());
    setMaxCards(value);
  };
  return Tilia.carve(function (param) {
              var derived = param.derived;
              return {
                      stacks: Tilia.source([], stacks(repo, path)),
                      setActive: derived(setActive(repo.progress)),
                      start: derived(start(repo)),
                      setDayLength: setDayLength,
                      setMaxCards: setMaxCards$1,
                      dayLengthH: Tilia.lift(dayLengthH),
                      maxCards: Tilia.lift(maxCards$1),
                      stats: derived(stats(function (prim) {
                                return Date.now();
                              }))
                    };
            });
}

export {
  isActive ,
  stats ,
  start ,
  loadProgress ,
  stacks ,
  setActive ,
  make ,
}
/* Tilia Not a pure module */
