// Generated by ReScript, PLEASE EDIT WITH CARE

import * as S from "sury/src/S.mjs";
import * as Stack from "../api/entity/Stack.mjs";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as System from "../../service/System.mjs";
import * as Vitest from "vitest";
import * as Nodefs from "node:fs";
import * as Nodepath from "node:path";
import * as VitestBdd from "vitest-bdd";
import * as StackParser from "../feature/StackParser.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.mjs";

var fixtures = Nodepath.join(process.cwd(), "src/domain/test/fixtures");

function readFixture(filename) {
  return Nodefs.readFileSync(Nodepath.join(fixtures, filename), "utf8");
}

VitestBdd.Given("a {string} file content", (function (param, filename) {
        var step = param.step;
        var content = readFixture(filename);
        var stackRef = {
          contents: undefined
        };
        step("I parse the stack", (function () {
                stackRef.contents = StackParser.parse(content);
              }));
        step("the stack info should contain", (function (table) {
                var stack = Core__Option.getExn(stackRef.contents, undefined);
                var records = VitestBdd.toRecords(table);
                records.forEach(function (record) {
                      var field = Core__Option.getExn(record.field, undefined);
                      var value = Core__Option.getExn(record.value, undefined);
                      switch (field) {
                        case "chapter" :
                            return Vitest.expect(stack.info.chapter).toBe(value);
                        case "course" :
                            return Vitest.expect(stack.info.course).toBe(value);
                        case "id" :
                            return Vitest.expect(stack.info.id).toBe(value);
                        case "kind" :
                            var kind;
                            switch (value) {
                              case "Quiz" :
                                  kind = "quiz";
                                  break;
                              default:
                                kind = "cards";
                            }
                            return Vitest.expect(stack.info.kind).toBe(kind);
                        case "level" :
                            var level;
                            switch (value) {
                              case "Pro" :
                                  level = "pro";
                                  break;
                              default:
                                level = "regular";
                            }
                            return Vitest.expect(stack.info.level).toBe(level);
                        case "tags" :
                            var tags = value.split(",").map(function (prim) {
                                  return prim.trim();
                                });
                            return Vitest.expect(stack.info.tags).toEqual(tags);
                        case "title" :
                            return Vitest.expect(stack.info.title).toBe(value);
                        default:
                          return ;
                      }
                    });
              }));
      }));

var syst = System.make();

function mockSystem() {
  var output = {};
  var writeFileSync = function (path, content, _encoding) {
    output[path] = content;
  };
  var readFileSync = function (path, encoding) {
    var v = output[path];
    if (v !== undefined) {
      return v;
    } else {
      return syst.fs.readFileSync(path, encoding);
    }
  };
  var existsSync = function (path) {
    var match = output[path];
    if (match !== undefined) {
      return true;
    } else {
      return syst.fs.existsSync(path);
    }
  };
  var init = syst.fs;
  return {
          fs: {
            existsSync: existsSync,
            readFileSync: readFileSync,
            readdirSync: init.readdirSync,
            writeFileSync: writeFileSync
          },
          path: syst.path,
          process: syst.process
        };
}

VitestBdd.Given("a clean {string} fixtures directory", (function (param, dirname) {
        var step = param.step;
        var match = mockSystem();
        var path = match.path;
        var join = path.join;
        var fs = match.fs;
        var stacksToJson = StackParser.makeStacksToJson(fs, path);
        var fdir = join(fixtures, dirname);
        step("I generate JSON files for all stacks", (function () {
                stacksToJson(fdir);
              }));
        step("the json file {string} should exist", (function (filename) {
                Vitest.expect(fs.existsSync(join(fdir, filename))).toBe(true);
              }));
        step("the json file {string} should contain", (function (filename, table) {
                var content = S.parseJsonStringOrThrow(fs.readFileSync(join(fdir, filename), "utf8"), Stack.stackSchema);
                var records = VitestBdd.toRecords(table);
                records.forEach(function (record) {
                      var field = Core__Option.getExn(record["json path"], undefined);
                      var value = Core__Option.getExn(record.value, undefined);
                      switch (field) {
                        case "cards.0.options.0.content" :
                            return Vitest.expect(content.cards[0].options[0].content).toBe(value);
                        case "cards.0.stackId" :
                            return Vitest.expect(content.cards[0].stackId).toBe(value);
                        case "info.chapter" :
                            return Vitest.expect(content.info.chapter).toBe(value);
                        case "info.course" :
                            return Vitest.expect(content.info.course).toBe(value);
                        case "info.id" :
                            return Vitest.expect(content.info.id).toBe(value);
                        case "info.kind" :
                            return Vitest.expect(content.info.kind).toBe(S.parseOrThrow(value, Stack.stackTypeSchema));
                        case "info.level" :
                            return Vitest.expect(content.info.level).toBe(S.parseOrThrow(value, Stack.levelSchema));
                        case "info.tags" :
                            var tags = value.split(",").map(function (prim) {
                                  return prim.trim();
                                });
                            return Vitest.expect(content.info.tags).toEqual(tags);
                        case "info.title" :
                            return Vitest.expect(content.info.title).toBe(value);
                        default:
                          return Js_exn.raiseError("Unknown field: " + field);
                      }
                    });
              }));
      }));

export {
  fixtures ,
  readFixture ,
  syst ,
  mockSystem ,
}
/* fixtures Not a pure module */
